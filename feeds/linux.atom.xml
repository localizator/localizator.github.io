<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>localizator@notes</title><link href="http://localizator.github.io/" rel="alternate"></link><link href="http://localizator.github.io/feeds/linux.atom.xml" rel="self"></link><id>http://localizator.github.io/</id><updated>2014-04-03T00:00:00+03:00</updated><entry><title>Вийшло вільне ядро GNU Linux-libre 3.14-gnu.</title><link href="http://localizator.github.io/2014-04-03/linux-libre-314/" rel="alternate"></link><updated>2014-04-03T00:00:00+03:00</updated><author><name>localizator</name></author><id>tag:localizator.github.io,2014-04-03:2014-04-03/linux-libre-314/</id><summary type="html">&lt;p&gt;&lt;center&gt;&lt;img alt="Freedo" src="/images/2014/04/freedo.png" /&gt;&lt;/center&gt; &lt;/p&gt;
&lt;p&gt;Вийшло вільне ядро &lt;strong&gt;GNU Linux-libre 3.14-gnu&lt;/strong&gt; з кодовим ім'ям &lt;strong&gt;«Freedom Pi»&lt;/strong&gt;. GNU Linux-libre — вільна версія ядра Linux, яка підходить для використання з операційною системою GNU.&lt;/p&gt;
&lt;p&gt;У даному ядрі видалені всі пропрієтарні компоненти. Ядро Linux-libre було спочатку в дистрибутиві gNewSense GNU/Linux. У 2008 році ядро стало частиною проекту, підтримуваним FSF в Латинській Америці, а в 2012 році стало частиною проекту GNU. &lt;/p&gt;
&lt;p&gt;Талісманом вільного ядра є Freedo, блакитний пінгвін, який щойно вийшов з душу.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Список змін:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Припинена підтримка aic7xxx_old и cs46xx.&lt;br /&gt;
Додана функція &lt;code&gt;reject_firmware_direct&lt;/code&gt; в сценарій чистки коду deblob.&lt;br /&gt;
Пропрієтарні компоненти були видалені з драйверів bnx2x, bt_mrvl, cs46xx.&lt;br /&gt;
Припинена підтримка btmtk.&lt;/p&gt;
&lt;p&gt;&lt;a href="http://lists.gnu.org/archive/html/info-gnu/2014-03/msg00025.html" target="_blank"&gt;gnu.org&lt;/a&gt;&lt;/p&gt;</summary><category term="linux"></category><category term="kernel"></category><category term="libre"></category></entry><entry><title>Chromium адаптований для Wayland.</title><link href="http://localizator.github.io/2013-09-21/chromium-wayland/" rel="alternate"></link><updated>2013-09-21T00:00:00+03:00</updated><author><name>localizator</name></author><id>tag:localizator.github.io,2013-09-21:2013-09-21/chromium-wayland/</id><summary type="html">&lt;p&gt;Тьяго Віньятті (Tiago Vignatti) з компанії Intel &lt;a href="http://vignatti.com/2013/09/18/welcome-to-chromiums-ozone-wayland/" target="_blank"&gt;&lt;strong&gt;повідомив&lt;/strong&gt;&lt;/a&gt; про успішне забезпечення роботи браузера Chromium в оточенні Wayland. Незважаючи на успішний запуск, проект поки не вийшов зі стадії розробки і вимагає додаткової стабілізації. Робота поверх Wayland організована завдяки створенню Ozone-Wayland, адаптованого для роботи з Wayland набору C++ класів Ozone, що використовуються в Chromium для абстрагування виведення на різні віконні системи. Проведена робота також дозволяє організувати виконання в оточенні Wayland та інших продуктів на кодової базі Chromium, в тому числі браузера Chrome і операційної системи ChromeOS.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Chromium on Wayland" src="/images/2013/09/0_1379570167.png" /&gt;  &lt;/p&gt;</summary><category term="chromium"></category><category term="wayland"></category></entry><entry><title>Вийшов офіційний клієнт Яндекс.Диск для Linux</title><link href="http://localizator.github.io/2013-08-27/yandex-disk-official-released-linux/" rel="alternate"></link><updated>2013-08-27T00:00:00+03:00</updated><author><name>localizator</name></author><id>tag:localizator.github.io,2013-08-27:2013-08-27/yandex-disk-official-released-linux/</id><summary type="html">&lt;p&gt;Яндекс.Диск - хмарний сервіс компанії Яндекс. Раніше з Linux працював тільки через WebDAV, для чого були придатні лише деякі файлові менеджери, або монтування за допомогою davfs2.&lt;/p&gt;
&lt;p&gt;Тепер випущений клієнт. Консольний, вихідні коди закриті - але настроювати зручніше, ніж davfs2, а синхронізація локальних файлів не вимагає скриптової обв'язки. Досить встановити програму, налаштувати підключення, а потім вибрати каталоги, які підлягають або не підлягають синхронізації.
&lt;!-- more --&gt;
У нього є вся основна функціональність, яка є у клієнтів для OS X і Windows, і навіть більше (сімлінки!), і одна особливість - він консольний.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Яндекс.Диск" src="/images/2013/09/yandex_disk.png" /&gt;  &lt;/p&gt;
&lt;p&gt;Нижче читайте про те, як він налаштовується, що конкретно вміє, і про те, як саме він влаштований і що в ньому було непросто зробити.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Встановлення&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Встановити його можна &lt;a href="http://repo.yandex.ru/yandex-disk/"&gt;тут&lt;/a&gt;. Відразу після установки пакета в терміналі з'явиться команда &lt;strong&gt;yandex-disk&lt;/strong&gt;, через яку в подальшому і йде робота з хмарою Яндекса. Після цього потрібно вручну запустити команду &lt;strong&gt;setup&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Майстер налаштування дозволяє в режимі діалогу вибрати папку для синхронізації, включити автозапуск при старті системи, налаштувати роботу через проксі-сервер (якщо звичайно ви ним користуєтеся) і авторизуватися в Яндекс.Диск. При налаштуванні вручну насамперед необхідно авторизуватися. Після цього в папці .config, розташованої в домашньому каталозі, буде створений конфіг, в якому можна буде налаштувати шлях до папки синхронізації (можна вказати в консолі вручну), прописати шлях до файлу токену, вказати папки, які будуть чи не будуть синхронізуватися, і прописати налаштування проксі-сервера.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Команди&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Підготовча робота закінчена, залишилося запустити демон однієї з команд. Вони дозволять вам синхронізувати файли і папки і користуватися ними скрізь, де є інтернет .&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;sync&lt;/strong&gt; - запустить демон, синхронізує все, що знаходиться в папці Диска, і зупинить демон.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;start&lt;/strong&gt; - зробить те ж саме, але без зупинки демона після завершення синхронізації. При використанні start демон залишається запущений і всі зміни, що відбуваються в папці Диска , будуть синхронізуватися автоматично.&lt;/li&gt;
&lt;li&gt;Ввівши в терміналі &lt;strong&gt;stop&lt;/strong&gt;, можна в будь-який момент зупинити запущений демон, якщо він вам заважає.&lt;/li&gt;
&lt;li&gt;Командою &lt;strong&gt;status&lt;/strong&gt; можна дізнатися , в якому статусі знаходиться ядро ​​синхронізації.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Працювати з папкою диска можна як з терміналу, так і з Nautilus'a.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Що вміє&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Консольний клієнт дозволяє поділитися файлом або текою за допомогою команди &lt;strong&gt;publish&lt;/strong&gt; (якщо файл знаходиться не в папці диска, перед публікацією він буде туди скопійований). Посилання буде доступна в терміналі, і будь-яка людина, перейшовши по ньому, зможе подивитися або зберегти собі опублікований вами файл або теку. Якщо випадково був опублікований не той файл, за допомогою команди &lt;strong&gt;unpublish&lt;/strong&gt; можна закрити доступ до публічного об'єкту.&lt;/p&gt;
&lt;p&gt;У Яндекс.Диск можлива вибіркова синхронізація. Команда &lt;strong&gt;exclude&lt;/strong&gt; дозволить виключити папку з синхронізації: всі зміни, зроблені в ній після цього, не будуть відправлені в хмару.&lt;/p&gt;
&lt;p&gt;Опція &lt;strong&gt;read-only&lt;/strong&gt; дозволить міняти файли локально, без заливки їх в хмару. При виникненні конфліктів з локальними змінами, останні будуть збережені в перейменованих файлах, а зміни з хмари будуть синхронізовані. Опція &lt;strong&gt;overwrite&lt;/strong&gt; буде перезаписувати локально змінені файли в режимі read-only .&lt;/p&gt;
&lt;p&gt;Не можемо не похвалитися самим цікавим нововведенням в ядрі синхронізації - відтепер ми підтримуємо синхронізацію символічних посиланнь (symlink)! Якщо виникнуть труднощі і питання у використанні консольного клієнта команди man і help просто і доступно допоможуть у них розібратися.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Як зроблено&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Щоб у майбутньому код можна було використовувати для реалізації клієнтів під різні ОС, було прийнято рішення писати його на C++. Специфічні для різних операційних систем шматки коду ми винесли в окремі функції чи класи, а під кожну платформу писали свою реалізацію. В якості основних кроссплатформенних бібліотек ми взяли Boost, OpenSSL і JsonCpp, а системою контролю версій став git. Клієнт під Linux збирався за допомогою autoconf. Код писався і налагоджувався у зв'язці KDevelop + консольний gdb  або в Qt Creator'е (залежно від уподобань розробника) .&lt;/p&gt;
&lt;p&gt;Взаємодія з хмарою і синхронізація відбувається за допомогою бібліотеки ядра Яндекс.Диск , яку використовують десктопні клієнти сервісу.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Як працює&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Консольний клієнт складається з двох частин: демона і клієнта. Спілкуються вони за допомогою текстових пакетів містять json - повідомлення, що посилаються через сокети (на Linux і Mac OS X використовуються unix - domain сокети). Асинхронна робота реалізована за допомогою бібліотеки boost::asio. Синхронізація доступу до даних реалізується через boost::asio::io_service::strand, що дозволяє не думати про проблему одночасного доступу до даних декількох потоків, а також виключає появу deadlock-ів.&lt;/p&gt;
&lt;p&gt;Для локалізації ми використовуємо бібліотеку boost::locale. Текст всередині клієнта закодований в utf 8 і за необхідності перетворюється в специфічному для кожної операційної системи коді. Моніторинг файлової системи для Linux використовує inotify, чудово вписуються в асинхронну роботу boost::asio.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Як влаштована синхронізація&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Синхронізація - серце Яндекс.Диск, його ключова можливість. Завдання синхронізації файлового дерева з хмарою ділиться на кілька незалежних частин.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.&lt;/strong&gt; Моніторинг файлової системи. Ядро синхронізації Яндекс.Диск проектувалося і створювалося як переносима абстракція, здатна виконувати поставлені завдання на всіх підтримуваних платформах. Але така проблема, як моніторинг файлової системи не реалізується ні стандартної бібліотекою C++, ні навіть такими монстрами як boost. Більше того, навіть використовуючи «рідне» API операційної системи, ми отримуємо набір подій, специфічний для кожної платформи.&lt;/p&gt;
&lt;p&gt;Для моніторингу файлової системи був спроектований інтерфейс «спостерігача» , здатного стежити за подіями в певній директорії і повертає список подій, що відбулися в ній. Причому для кожної підтримуваної платформи набір цих подій відрізняється. Наприклад, Mac OS X здатна повідомити тільки про факт якогось зміни в одній з дочірніх директоріях без деталізації. А ось Windows і Linux повертають повний набір, включаючи створення, видалення, модифікацію і переміщення об'єктів. Хоча практика показувала, що подіям на платформі Windows довіряти не варто і самим надійним варіантом залишається лістинг директорії після отримання оповіщення.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.&lt;/strong&gt; Індексація локальних файлів і директорій. Для контролю цілісності та реалізації дельта -оновлення файлів ядро синхронізації Яндекс.Диск використовує дайджести - набори контрольних сум файлу і окремих його частин. Для всього файлу ми розраховуємо стійкий хеш SHA-256 і набір менш стійких сум для окремих блоків. Кожен файл, що знаходиться в папці Яндекс.Диск і не потрапляє до списку винятків, повинен бути проіндексований. Але обчислення хеша SHA-256 досить дорога операція, а розрахунок хешей при кожному запуску ПО був б великою витратою ресурсів. Тому після того, як завершується індексація файлу , ядро синхронізації зберігає отриманий дайджест в «банці» - спеціальному сховищі, що знаходиться у службовій директорії Яндекс.Диск. Для пошуку дайджестів в сховище використовується унікальний ідентифікатор файлу - inode (розмір і час останньої зміни) . На жаль, подібний підхід не позбавлений недоліків. Наприклад, багато файлів - криптоконтейнера зберігають час останньої модифікації незмінним навіть після запису .&lt;/p&gt;
&lt;p&gt;Напевно, крім тонкощів роботи з символічними посиланнями , нічого в лістингу директорій не представляє особливого інтересу. Для успішного завершення синхронізації ядро повинне виявляти і виключати з синхронізації циклічні гілки .&lt;/p&gt;
&lt;p&gt;Взагалі , символічні посилання - це справжня «головна біль» для ядра синхронізації. Вони можуть вказувати у довільні місця файлової системи , і ні до всіх з них можна застосовувати однакові правила синхронізації. Наприклад , пакети додатків Mac OS X дуже часто містять в собі символічні посилання на директорії системних бібліотек , і їх синхронізація в хмару була б небажана - особливо між різними версіями ОС . Але в той же час можливість синхронізувати додаткові директорії за допомогою символічних посилань - дуже приваблива можливість , упускати яку не хотілося.&lt;/p&gt;
&lt;p&gt;Тому для синхронізації символічних посилань була введена особлива політика , завдяки якій ядро ​​може вибирати специфічний варіант синхронізації для кожної символічного посилання - залежно від розташування об'єкта , на який вона вказує.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3&lt;/strong&gt;. Отримання дерева хмарної файлової системи. Для вирішення проблеми синхронізації мало мати локальну файлову структуру і дайджести файлів - необхідно отримати поточний стан файлової системи в хмарі. Якби ядру синхронізації щоразу доводилося обходити дерево за допомогою методу PROPFIND , то кожен цикл синхронізації займав би невиправдано багато часу і створював би зайве навантаження на канал. Тому ПО Яндекс.Диск використовує спеціальний API , який дає можливість отримувати поточний стан дерева файлів у хмарі і зміни, що відбулися в ньому , починаючи з деякого відомого моменту, що визначається версією дерева.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4&lt;/strong&gt;. Отримання оповіщень про зміну хмарної файлової системи. Синхронізація файлів в реальному часі вимагає своєчасного одержання оповіщень про зміни , що сталися з файлами в хмарі. Можна було б використовувати періодичний опитування сервера клієнтами , але , оцінивши можливу кількість клієнтів , ми прийшли до висновку , що такий підхід виявиться слабо масштабованим і приведе до швидкої перевантаженні інфраструктури сервісу. Після недовгих пошуків ми зупинилися на протоколі XMPP . Одна з його реалізацій вже довгий час працює в Яндексі. Вона була розроблена командою , яка пізніше займалися створенням сервера WebDAV для проекту Яндекс.Диск , тому складнощів з інтеграцією цього протоколу не виникло.&lt;/p&gt;
&lt;p&gt;Зараз пуш -сповіщення , оброблювані ядром синхронізації , включають в себе не тільки події, що відбулися безпосередньо з файлами або папками в хмарі Яндекс.Диск , але і різні сервісні повідомлення. Наприклад про видачу додаткового місця або діях інших користувачів у спільних папках . Додавання цих подій до наявного Протоколу не викликало великих труднощів завдяки розширюваності XMPP , що в черговий раз підтвердило правильність нашого вибору.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5&lt;/strong&gt;. Створення списку операцій синхронізації. Після того як у розпорядженні ядра синхронізації виявляються обидва дерева файлів - локальне та віддалене - можна приступати до самої процедури синхронізації. Для цього застосовується спеціальний алгоритм порівняння дерев , що приймає на вхід окрім двох згаданих дерев , ще й третє - останнє синхронізоване . В результаті роботи алгоритму виходить список операцій , які необхідно здійснити над локальними і віддаленими файлами і директорій для приведення дерев до загального вигляду .&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;6&lt;/strong&gt;. Обробка черги операцій синхронізації. Створення списку операцій для локального та віддаленого дерев відбувається незалежно. В результаті можуть з'явитися конфліктуючі операції . Наприклад , видалення в хмарі файлу , який був у ньому змінено і ще не синхронізований локально , або зміна файлу одночасно локально і в хмарі. Конфлікти модифікації / видалення завжди вирішуються ядром на користь модифікації , а конфлікти подвійний модифікації дозволяються перейменуванням однією з версій файлу. Таким чином ми можемо гарантувати збереження даних і даємо можливість після завершення синхронізації самому користувачеві вирішити, яке з змін більше йому підходить в кожному конкретному випадку.&lt;/p&gt;
&lt;p&gt;Операції синхронізації повинні підкорятися строгому порядку , не можна передавати файл , поки не створена його батьківська директорія . Так само директорію не можна видаляти , поки всередині неї залишаються файли , які потрібно перемістити на нове місце. Алгоритм порівняння дерев вже створює операції в потрібному порядку , але при виникненні помилок він може порушитися . Для запобігання цій ситуації у кожній операції є список залежностей - набір операцій , які повинні завершитися до початку її виконання , і набір операцій , які не повинні початися , поки вона не буде виконана .&lt;/p&gt;
&lt;p&gt;Крім залежностей на порядок виконання операцій впливає її пріоритет . Наприклад , операції передачі файлів виконуються в залежності від розмірів файлів - від маленьких до великих .&lt;/p&gt;
&lt;p&gt;Всі ці завдання виконуються одночасно , накладаючи додаткові вимоги на якість синхронізації паралельних процесів і розподіл ресурсів всередині ядра синхронізації Яндекс.Диск. Якщо у вас ще немає Я.Диска , завести його можна &lt;a href="http://disk.yandex.ru/"&gt;тут&lt;/a&gt;, а встановити для Linux - тут: &lt;a href="http://repo.yandex.ru/yandex-disk/"&gt;repo.yandex.ru/yandex-disk&lt;/a&gt; .&lt;/p&gt;</summary><category term="yandex"></category><category term="disk"></category></entry></feed>